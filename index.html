<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>店內 AR 隱藏小狐狸</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; }
    #overlay { position: fixed; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
    #topbar { margin: env(safe-area-inset-top) 12px 0; padding: 10px 12px; background: rgba(0,0,0,.45); color: #fff; border-radius: 12px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; backdrop-filter: blur(6px); max-width: calc(100% - 24px); }
    #topbar b { color: #a0e9ff; }
    #foot { margin: 0 12px env(safe-area-inset-bottom); display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap; }
    .chip { pointer-events: auto; user-select: none; padding: 8px 12px; color: #fff; background: rgba(0,0,0,.55); border: 1px solid rgba(255,255,255,.15); border-radius: 999px; font-size: 14px; }
    #hint { position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%); padding: 12px 16px; background: rgba(255,255,255,.95); color: #111; border-radius: 12px; font-weight: 700; font-size: 18px; display: none; box-shadow: 0 8px 30px rgba(0,0,0,.35); }
    #error { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); padding: 10px 12px; background: #ff4d4f; color: #fff; border-radius: 10px; display: none; font-weight: 600; }
    #enterARBtn { pointer-events: auto; user-select: none; padding: 10px 14px; color: #111; background: #a0e9ff; border: none; border-radius: 999px; font-size: 16px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    #enterARBtn[disabled] { opacity: .5; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="topbar">
      <div><b>玩法：</b>移動在店內（15 公尺範圍）尋找 5 隻隱藏的小狐狸。靠近到 1 公尺且位在鏡頭前方會出現提示。</div>
    </div>
    <div id="foot">
      <button id="enterARBtn">啟動相機 / 進入 AR</button>
      <div class="chip" id="compatMsg">若按鈕無法使用：請以 HTTPS 網址（或 localhost）在行動裝置的 Chrome/Edge/Safari 開啟</div>
    </div>
      <div class="chip">範例模型：fox_stand.glb / fox_sleep.glb</div>
    </div>
  </div>
  <div id="hint">這裡有動物的足跡</div>
  <div id="error"></div>

  <!-- three.js & loaders (r165 or later) -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/webxr/ARButton.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/DRACOLoader.js';
    import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/RGBELoader.js';
    import { clone as SkeletonClone } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/utils/SkeletonUtils.js';

    const overlayRoot = document.body;
    const enterBtn = document.getElementById('enterARBtn');
    const compatMsg = document.getElementById('compatMsg'); // for dom-overlay
    const hintEl = document.getElementById('hint');
    const errorEl = document.getElementById('error');

    // Basic renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444466, 1.0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // Optional: subtle environment for nicer PBR
    new RGBELoader()
      .setDataType(THREE.HalfFloatType)
      .load('https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/hdri/venice_sunset_1k.hdr', (hdr) => {
        const pmrem = new THREE.PMREMGenerator(renderer);
        pmrem.compileEquirectangularShader();
        const env = pmrem.fromEquirectangular(hdr).texture;
        scene.environment = env;
        hdr.dispose();
        pmrem.dispose();
      });

    const camera = new THREE.PerspectiveCamera();

    // Fox asset loader
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/libs/draco/');
    gltfLoader.setDRACOLoader(draco);

    const FOX_FILES = ['fox_stand.glb','fox_sleep.glb'];
    const foxBase = { stand: null, sleep: null };

    async function loadFoxBase() {
      const [stand, sleep] = await Promise.all([
        gltfLoader.loadAsync(FOX_FILES[0]).catch(e => { throw new Error('無法載入 fox_stand.glb'); }),
        gltfLoader.loadAsync(FOX_FILES[1]).catch(e => { throw new Error('無法載入 fox_sleep.glb'); })
      ]);
      foxBase.stand = stand.scene;
      foxBase.sleep = sleep.scene;
      // Normalize base scale lightly if models are too big/small (tweak as needed)
      [foxBase.stand, foxBase.sleep].forEach(root => {
        root.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const targetHeight = 0.35; // ~35cm 高的小狐狸
        const s = targetHeight / Math.max(size.y, 1e-3);
        root.scale.setScalar(s);
      });
    }

    // Create 5 foxes randomly within 15m radius around starting pose
    const FOX_COUNT = 5; // 顧客要看到 5 隻
    const FOX_RADIUS = 15; // 15 公尺內
    const FOX_MIN_RADIUS = 2.5; // 避免一開始就貼很近
    const foxes = []; // {mesh, position}

    function randomInRing(minR, maxR) {
      const r = Math.sqrt(Math.random() * (maxR*maxR - minR*minR) + minR*minR);
      const theta = Math.random() * Math.PI * 2;
      return new THREE.Vector2(Math.cos(theta)*r, Math.sin(theta)*r);
    }

    function makeFoxInstance(kind = 'stand') {
      const base = kind === 'sleep' ? foxBase.sleep : foxBase.stand;
      const root = SkeletonClone(base);
      root.rotation.y = Math.random()*Math.PI*2;
      return root;
    }

    let placed = false;

    async function init() {
      try {
        await loadFoxBase();
      } catch (e) {
        showError(e.message || '模型載入失敗，請確認檔名與路徑。');
      }

      // Prepare AR button but don't auto-append; we will mount it into our UI
      let xrButton;
      const setupARButton = () => {
        try {
          xrButton = ARButton.createButton(renderer, {
            requiredFeatures: ['local-floor'],
            optionalFeatures: ['dom-overlay','unbounded'],
            domOverlay: { root: overlayRoot }
          });
          // Style & move the button into our footer
          xrButton.style.display = 'none'; // keep hidden, we proxy via enterBtn
          document.body.appendChild(xrButton);
          enterBtn.disabled = false;
        } catch (err) {
          showError('建立 AR 按鈕失敗：' + (err?.message || err));
          enterBtn.disabled = true;
        }
      };

      // If WebXR available, set up AR; else fallback to camera permission test only
      if (navigator.xr) {
        setupARButton();
      } else {
        compatMsg.textContent = '此瀏覽器不支援 WebXR AR，仍可授權相機測試，但無法進入 AR。';
      }

      renderer.setAnimationLoop(onXRFrame);
      window.addEventListener('resize', onResize);
    }

      try {
        await loadFoxBase();
      } catch (e) {
        showError(e.message || '模型載入失敗，請確認檔名與路徑。');
      }

      const btn = ARButton.createButton(renderer, {
        requiredFeatures: ['local-floor'],
        optionalFeatures: ['dom-overlay','unbounded'],
        domOverlay: { root: overlayRoot }
      });
      document.body.appendChild(btn);

      renderer.setAnimationLoop(onXRFrame);
      window.addEventListener('resize', onResize);
    }

    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Explicit user-gesture flow to request camera permission first
    enterBtn.addEventListener('click', async () => {
      enterBtn.disabled = true;
      try {
        // 1) Ask for camera (user gesture required)
        if (navigator.mediaDevices?.getUserMedia) {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
          // Immediately stop tracks; we only needed the permission prompt here.
          stream.getTracks().forEach(t => t.stop());
        }
        // 2) If WebXR AR is available, forward to ARButton's flow
        const btn = document.querySelector('button.webxr-ar-button');
        if (btn) {
          btn.click(); // triggers AR session
        } else if (!navigator.xr) {
          showError('已取得相機權限，但本瀏覽器不支援 WebXR AR。請改用支援的行動版 Chrome/Edge/Safari，並以 HTTPS 開啟。');
        }
      } catch (err) {
        showError('取得相機權限失敗：' + (err?.message || err));
      } finally {
        enterBtn.disabled = false;
      }
    );

    function placeFoxesAround(startCam) {
      // origin = camera position at session start
      const origin = new THREE.Vector3();
      startCam.getWorldPosition(origin);

      for (let i=0; i<FOX_COUNT; i++) {
        const v2 = randomInRing(FOX_MIN_RADIUS, FOX_RADIUS);
        const pos = new THREE.Vector3(origin.x + v2.x, 0.0, origin.z + v2.y); // 放在地板 y=0
        const kind = Math.random() < 0.5 ? 'stand' : 'sleep';
        const fox = makeFoxInstance(kind);
        fox.position.copy(pos);
        fox.userData.kind = kind;
        scene.add(fox);
        foxes.push(fox);
      }
      placed = true;
    }

    const tmpVec = new THREE.Vector3();
    const camForward = new THREE.Vector3();

    function updateHintVisibility() {
      let show = false;
      // 相機世界座標 & 前向向量
      camera.getWorldDirection(camForward).normalize();
      const camPos = camera.getWorldPosition(new THREE.Vector3());

      for (const fox of foxes) {
        tmpVec.copy(fox.position).sub(camPos);
        const dist = tmpVec.length();
        if (dist <= 1.0) {
          // 前方：與鏡頭前向的點積需為正，且夠對準（> 0.3）
          const dirToFox = tmpVec.normalize();
          const dot = camForward.dot(dirToFox);
          if (dot > 0.3) { show = true; break; }
        }
      }
      hintEl.style.display = show ? 'block' : 'none';
    }

    function onXRFrame(time, frame) {
      // Place foxes once when we have a reference space & camera
      if (!placed && renderer.xr.isPresenting) {
        placeFoxesAround(camera);
      }
      updateHintVisibility();
      renderer.render(scene, camera);
    }

    function showError(msg){
      errorEl.textContent = msg;
      errorEl.style.display = 'block';
      setTimeout(()=>{ errorEl.style.display = 'none'; }, 5000);
    }

    init();
  </script>
</body>
</html>
