<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta http-equiv="Permissions-Policy" content="camera=(self)" />
  <title>店內 AR 隱藏小狐狸</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; }
    #cameraPreview { position: fixed; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; background: #000; }
    canvas { position: fixed; inset: 0; z-index: 1; }
    #overlay { position: fixed; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 2; }
    #topbar { margin: env(safe-area-inset-top) 12px 0; padding: 10px 12px; background: rgba(0,0,0,.45); color: #fff; border-radius: 12px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, Helvetica, Arial; backdrop-filter: blur(6px); max-width: calc(100% - 24px); }
    #topbar b { color: #a0e9ff; }
    #hint { position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%); padding: 12px 16px; background: rgba(255,255,255,.95); color: #111; border-radius: 12px; font-weight: 700; font-size: 18px; display: none; box-shadow: 0 8px 30px rgba(0,0,0,.35); z-index: 3; }
    #error { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); padding: 10px 12px; background: #ff4d4f; color: #fff; border-radius: 10px; display: none; font-weight: 600; z-index: 3; }
  </style>
</head>
<body>
  <video id="cameraPreview" autoplay playsinline muted></video>
  <div id="overlay">
    <div id="topbar">
      <div><b>玩法：</b>移動在店內（15 公尺範圍）尋找 5 隻隱藏的小狐狸。靠近到 1 公尺且位在鏡頭前方會出現提示。</div>
    </div>
  </div>
  <div id="hint">這裡有動物的足跡</div>
  <div id="error"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/DRACOLoader.js';

    const videoEl = document.getElementById('cameraPreview');
    const hintEl = document.getElementById('hint');
    const errorEl = document.getElementById('error');

    // 啟動相機預覽（頁面載入就詢問權限）
    async function startCamera() {
      try {
        if (navigator.mediaDevices?.getUserMedia) {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio: false });
          videoEl.srcObject = stream;
        } else {
          showError('此瀏覽器不支援相機存取。');
        }
      } catch (e) {
        showError('相機開啟失敗：' + (e?.message || e));
      }
    }

    // three.js 基本設置
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444466, 1.0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/libs/draco/');
    gltfLoader.setDRACOLoader(draco);

    const FOX_FILES = ['fox_stand.glb','fox_sleep.glb'];
    const foxBase = { stand: null, sleep: null };

    async function loadFoxBase() {
      const [stand, sleep] = await Promise.all([
        gltfLoader.loadAsync(FOX_FILES[0]),
        gltfLoader.loadAsync(FOX_FILES[1])
      ]);
      foxBase.stand = stand.scene;
      foxBase.sleep = sleep.scene;
      [foxBase.stand, foxBase.sleep].forEach(root => {
        root.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const targetHeight = 0.35;
        const s = targetHeight / Math.max(size.y, 1e-3);
        root.scale.setScalar(s);
      });
    }

    const FOX_COUNT = 5;
    const FOX_RADIUS = 15;
    const FOX_MIN_RADIUS = 2.5;
    const foxes = [];

    function randomInRing(minR, maxR) {
      const r = Math.sqrt(Math.random() * (maxR*maxR - minR*minR) + minR*minR);
      const theta = Math.random() * Math.PI * 2;
      return new THREE.Vector2(Math.cos(theta)*r, Math.sin(theta)*r);
    }

    function makeFoxInstance(kind = 'stand') {
      const base = kind === 'sleep' ? foxBase.sleep : foxBase.stand;
      const root = base.clone(true);
      root.rotation.y = Math.random()*Math.PI*2;
      return root;
    }

    let placed = false;

    function placeFoxesAround(startCam) {
      const origin = new THREE.Vector3();
      startCam.getWorldPosition(origin);

      for (let i=0; i<FOX_COUNT; i++) {
        const v2 = randomInRing(FOX_MIN_RADIUS, FOX_RADIUS);
        const pos = new THREE.Vector3(origin.x + v2.x, 0.0, origin.z + v2.y);
        const kind = Math.random() < 0.5 ? 'stand' : 'sleep';
        const fox = makeFoxInstance(kind);
        fox.position.copy(pos);
        fox.userData.kind = kind;
        scene.add(fox);
        foxes.push(fox);
      }
      placed = true;
    }

    const tmpVec = new THREE.Vector3();
    const camForward = new THREE.Vector3();

    function updateHintVisibility() {
      let show = false;
      camera.getWorldDirection(camForward).normalize();
      const camPos = camera.getWorldPosition(new THREE.Vector3());

      for (const fox of foxes) {
        tmpVec.copy(fox.position).sub(camPos);
        const dist = tmpVec.length();
        if (dist <= 1.0) {
          const dirToFox = tmpVec.normalize();
          const dot = camForward.dot(dirToFox);
          if (dot > 0.3) { show = true; break; }
        }
      }
      hintEl.style.display = show ? 'block' : 'none';
    }

    function onFrame(time) {
      if (!placed) {
        placeFoxesAround(camera);
      }
      updateHintVisibility();
      renderer.render(scene, camera);
    }

    function showError(msg){
      errorEl.textContent = msg;
      errorEl.style.display = 'block';
      setTimeout(()=>{ errorEl.style.display = 'none'; }, 5000);
    }

    // 初始化
    (async () => {
      await startCamera();
      await loadFoxBase();
      renderer.setAnimationLoop(onFrame);
      window.addEventListener('resize', ()=>{
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    })();
  </script>
</body>
</html>
